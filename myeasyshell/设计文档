本程序主要由输入模块，命令解析和命令执行模块组成。将这几个模块放入死循环中，模拟shell。

输入模块由fgets函数完成，将用户输入放入字符数组buf中。

命令解析模块首先调用strtok函数将buf中字符由空格分开并分别将指针放置在arg_list数组中。
然后调用strcmp函数匹配命令中是否含有>,<,&,exit等特殊含义字符，并设置各flag，以供后面
执行时利用。例如用户输入ls -l &,strcmp匹配到&，并设置flag，ls 和 -l的指针就分别放入
arg_list[0],arg_list[1]中，并将arg_list[2]置0。

命令执行模块中，先fork子进程，在子进程中根据各个flag进行不同处理。
一，对于普通命令，直接将arg_list作为参数传给execvp，在子进程中执行命令，父进程waitpid阻塞
等待子进程结束。
二，针对输出重定向 >,首先利用open函数创建或者覆盖 > 右侧文件，并用dup2将其文件描述符复制到
标准输出。
三，输入重定向同上
四，后台处理 & ，与普通命令处理方式类似，只是父进程不再阻塞等待子进程结束，而是直接返回进入
下一个循环。（本来想让子进程创建新的进程组，成为后台进程组，但是创建虽然成功，命令会阻塞，
后面再实验改进一下）
五，退出命令 exit,这个在命令解析时匹配到exit就直接退出了，另外程序中添加了信号处理程序，ctrl+
C也会退出。
六，设定提示符，通过setenv对PS1进行赋值，并通过getenv取得变量，重新打印。 



